# Aim

This will be an ad hoc series of classes to get you proficient in C#. From what you have told me, you have some experience working with C# programs but feel that you have not had the opportunity to gain deeper understanding of some areas.  

I will be taking a concept first approach in these classes, which means that I will try to highlight the concepts which are relevant to what we are learning. This is different from how programming is often taught, where instructors would show you commands and actions that you have to perform without giving you a better understanding of the context behind it. I will try to give you mental models of what is going on, because once you build a conceptual framework in your mind, you can detect for yourselves where the gaps in your knowledge are and use that to target further study. Also, job interviews will often be more focussed on concepts rather than remembering the names of keywords or types, because the concepts are portable across different languages, and it often happens that jobs are offered to candidates who have no experience of the right language but showed a good understanding of how to construct a good program.

The first concept I would like you to understand throughout is that programming languages **do not perform any magic**. You will hear people talking about features like strongly typed, dynamically typed, scripted, object oriented, procedural, functional languages as if these are some new advancements in digital computing, but the end goal of every language is to produce a **machine language program** that gives a computer a list of instructions to run, and which data to run it on. The language features don't enable the computer to do something it couldn't already do, and for the last fifty years at least, each instruction either manipulates some data (like doing some arithmetic) or determines which instruction to do next. (Virtually all of the development in processors over these years has been to do with running things simultaneously, under secure environments, and other optimisations - the mental model of how computations are performed has not changed at all). 

To make the program more efficient (shorter), three of those instructions are **jump**, **call** and **return**. **Jump** simply tells the computer to go to the next instruction somewhere else, rather than the next in line. **Call** tells the computer to go to the next instruction somewhere else, but when it comes across a **return** instruction it should come back and continue where it left off. These instructions allow you to write some code in just one place, and then call it from different parts of the program. This way, you don't have to repeat lots of code that does the same thing.

To make the program do more complex tasks, and look like it has intelligence, a conditional version of **jump** allows the program to do something different depending on what the data looks like, such as checking if a value is zero and then deciding whether to jump elsewhere or continue with the next instruction. That's it! All the other instructions simply manipulate data. That is what every program looks like when it runs on a computer, and it doesn't matter whether you use Python or C# or Java to write it.

The early high level programming languages like C Pascal and Fortran introduced features like functions and loops (**do, while, foreach**, etc), but they didn't create any magic. They just helped the programmer by automatically inserting some structure into the machine language program. So a **for** loop is just a block of code that starts by setting a counter and incrementing it, and ends with a conditional **jump** instruction that takes execution back to the start of the block of code depending on whether it is time to quit the loop or not. And a **function** is just a block of code that reserves a bit of memory at the start so that it can store its local variables in there, and then releases that memory again at the end. A scoped block (e.g. the Javascript code inside braces { }) does something similar.

So when we go on to talk about object oriented programming, its important to remember there is **no magic** going on that is making the computer do something it couldn't do before. It's just making it easier for the programmer to write a program that reflects the business domain problem that needs to be solved, by helpfully inserting machine language instructions that has more predictable reliability and efficiency. So as you learn more about how classes work, it will be helpful to think about what is actually happening "under the cover". What you learn by doing that will be relevant whatever language you are working with, whether it is Java, Python, Javascript, C++, and it is a much more efficient way of learning programming than learning one language after another.

After each week's session, I'll try to write a summary of what we covered in the other documents in this folder.
